// Generated by CoffeeScript 1.6.2
(function() {
  'use strict';
  var callFunctionOrPass, cleanModuleName, coffeescript, commonJsWrapper, createJoinConfig, deepFreeze, ensureArray, exec, express, extend, flatten, fs, getConfigDeprecations, http, indent, install, listToObj, logger, normalizeChecker, normalizeConfig, normalizeDefinition, normalizeWrapper, os, pwd, recursiveExtend, replaceSlashes, setConfigDefaults, startDefaultServer, startsWith, sysPath;

  exec = require('child_process').exec;

  coffeescript = require('coffee-script');

  express = require('express');

  http = require('http');

  fs = require('fs');

  os = require('os');

  sysPath = require('path');

  logger = require('loggy');

  exports.startsWith = startsWith = function(string, substring) {
    return string.lastIndexOf(substring, 0) === 0;
  };

  exports.flatten = flatten = function(array) {
    return array.reduce(function(acc, elem) {
      return acc.concat(Array.isArray(elem) ? flatten(elem) : [elem]);
    }, []);
  };

  exports.callFunctionOrPass = callFunctionOrPass = function(thing, context) {
    if (context == null) {
      context = this;
    }
    if (typeof thing === 'function') {
      return thing.call(context);
    } else {
      return thing;
    }
  };

  exports.ensureArray = ensureArray = function(object) {
    if (Array.isArray(object)) {
      return object;
    } else {
      return [object];
    }
  };

  exports.extend = extend = function(object, properties) {
    Object.keys(properties).forEach(function(key) {
      return object[key] = properties[key];
    });
    return object;
  };

  recursiveExtend = function(object, properties) {
    Object.keys(properties).forEach(function(key) {
      var value;

      value = properties[key];
      if (typeof value === 'object' && (value != null)) {
        return recursiveExtend(object[key], value);
      } else {
        return object[key] = value;
      }
    });
    return object;
  };

  exports.deepFreeze = deepFreeze = function(object) {
    Object.keys(Object.freeze(object)).map(function(key) {
      return object[key];
    }).filter(function(value) {
      return typeof value === 'object' && (value != null) && !Object.isFrozen(value);
    }).forEach(deepFreeze);
    return object;
  };

  exports.formatError = function(error, path) {
    return "" + error.brunchType + " of '" + path + "' failed. " + (error.toString().slice(7));
  };

  exports.pwd = pwd = function() {
    return '.';
  };

  exports.install = install = function(rootPath, callback) {
    var prevDir;

    if (callback == null) {
      callback = (function() {});
    }
    prevDir = process.cwd();
    logger.info('Installing packages...');
    process.chdir(rootPath);
    return exec('npm install', function(error, stdout, stderr) {
      var log;

      process.chdir(prevDir);
      if (error != null) {
        log = stderr.toString();
        logger.error(log);
        return callback(log);
      }
      return callback(null, stdout);
    });
  };

  startDefaultServer = function(port, path, base, callback) {
    var serv, server;

    server = express();
    server.use(function(request, response, next) {
      response.header('Cache-Control', 'no-cache');
      response.header('Access-Control-Allow-Origin', '*');
      return next();
    });
    server.use(base, express["static"](path));
    server.all("" + base + "/*", function(request, response) {
      return response.sendfile(sysPath.join(path, 'index.html'));
    });
    serv = http.createServer(server);
    serv.listen(port, callback);
    return serv;
  };

  exports.startServer = function(config, callback) {
    var error, onListening, port, publicPath, server;

    if (callback == null) {
      callback = (function() {});
    }
    port = parseInt(config.server.port, 10);
    publicPath = config.paths["public"];
    onListening = function() {
      logger.info("application started on http://localhost:" + port + "/");
      return callback();
    };
    if (config.server.path) {
      try {
        server = require(sysPath.resolve(config.server.path));
        return server.startServer(port, publicPath, onListening);
      } catch (_error) {
        error = _error;
        return logger.error("couldn\'t load server " + config.server.path + ": " + error);
      }
    } else {
      return startDefaultServer(port, publicPath, config.server.base, onListening);
    }
  };

  exports.replaceSlashes = replaceSlashes = function(config) {
    var changePath, files;

    changePath = function(string) {
      return string.replace(/\//g, '\\');
    };
    files = config.files || {};
    Object.keys(files).forEach(function(language) {
      var lang, newJoinTo, order;

      lang = files[language] || {};
      order = lang.order || {};
      Object.keys(order).forEach(function(orderKey) {
        return lang.order[orderKey] = lang.order[orderKey].map(changePath);
      });
      switch (toString.call(lang.joinTo)) {
        case '[object String]':
          return lang.joinTo = changePath(lang.joinTo);
        case '[object Object]':
          newJoinTo = {};
          Object.keys(lang.joinTo).forEach(function(joinToKey) {
            return newJoinTo[changePath(joinToKey)] = lang.joinTo[joinToKey];
          });
          return lang.joinTo = newJoinTo;
      }
    });
    return config;
  };

  normalizeChecker = function(item) {
    switch (toString.call(item)) {
      case '[object RegExp]':
        return function(string) {
          return item.test(string);
        };
      case '[object Function]':
        return item;
      default:
        throw new Error("Config item " + item + " is invalid.Use RegExp or Function.");
    }
  };

  listToObj = function(acc, elem) {
    acc[elem[0]] = elem[1];
    return acc;
  };

  createJoinConfig = function(configFiles) {
    var result, types;

    types = Object.keys(configFiles);
    result = types.map(function(type) {
      return configFiles[type].joinTo;
    }).map(function(joinTo) {
      var object;

      if (typeof joinTo === 'string') {
        object = {};
        object[joinTo] = /.+/;
        return object;
      } else {
        return joinTo;
      }
    }).map(function(joinTo, index) {
      var makeChecker, subConfig;

      makeChecker = function(generatedFilePath) {
        return [generatedFilePath, normalizeChecker(joinTo[generatedFilePath])];
      };
      subConfig = Object.keys(joinTo).map(makeChecker).reduce(listToObj, {});
      return [types[index], subConfig];
    }).reduce(listToObj, {});
    return Object.freeze(result);
  };

  indent = function(js) {
    return js.replace(/(\\)?\n(?!\n)/g, function($0, $1) {
      if ($1) {
        return $0;
      } else {
        return '\n  ';
      }
    });
  };

  exports.cleanModuleName = cleanModuleName = function(path) {
    return path.replace(new RegExp('\\\\', 'g'), '/').replace(/^app\//, '');
  };

  commonJsWrapper = function(addSourceURLs) {
    if (addSourceURLs == null) {
      addSourceURLs = false;
    }
    return function(fullPath, fileData, isVendor) {
      var data, definition, path, sourceURLPath;

      sourceURLPath = cleanModuleName(fullPath);
      path = JSON.stringify(sourceURLPath.replace(/\.\w+$/, ''));
      data = addSourceURLs ? JSON.stringify("" + fileData + "\n//@ sourceURL=" + sourceURLPath) : fileData;
      if (isVendor) {
        if (addSourceURLs) {
          return "Function(" + data + ").call(this);\n";
        } else {
          return "" + data + ";\n";
        }
      } else {
        definition = addSourceURLs ? "Function('exports, require, module', " + data + ")" : "function(exports, require, module) {\n  " + (indent(data)) + "\n}";
        return "window.require.register(" + path + ", " + definition + ");\n";
      }
    };
  };

  normalizeWrapper = function(typeOrFunction, addSourceURLs) {
    switch (typeOrFunction) {
      case 'commonjs':
        return commonJsWrapper(addSourceURLs);
      case 'amd':
        return function(fullPath, data) {
          var path;

          path = cleanModuleName(fullPath);
          return "define('" + path + "', ['require', 'exports', 'module'], function(require, exports, module) {\n  " + (indent(data)) + "\n});";
        };
      case false:
        return function(path, data) {
          return "" + data;
        };
      default:
        if (typeof typeOrFunction === 'function') {
          return typeOrFunction;
        } else {
          throw new Error('config.modules.wrapper should be a function or one of:\
"commonjs", "amd", false');
        }
    }
  };

  normalizeDefinition = function(typeOrFunction) {
    var data, path;

    switch (typeOrFunction) {
      case 'commonjs':
        path = sysPath.join(__dirname, '..', 'vendor', 'require_definition.js');
        data = fs.readFileSync(path).toString();
        return function() {
          return data;
        };
      case 'amd':
      case false:
        return function() {
          return '';
        };
      default:
        if (typeof typeOrFunction === 'function') {
          return typeOrFunction;
        } else {
          throw new Error('config.modules.definition should be a function\
or one of: "commonjs", false');
        }
    }
  };

  exports.setConfigDefaults = setConfigDefaults = function(config, configPath) {
    var conventions, join, joinRoot, modules, paths, _base, _base1, _base2, _ref, _ref1, _ref10, _ref11, _ref12, _ref13, _ref14, _ref15, _ref16, _ref17, _ref18, _ref19, _ref2, _ref20, _ref21, _ref22, _ref23, _ref24, _ref25, _ref26, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9,
      _this = this;

    join = function(parent, name) {
      return sysPath.join(config.paths[parent], name);
    };
    joinRoot = function(name) {
      return join('root', name);
    };
    paths = (_ref = config.paths) != null ? _ref : config.paths = {};
    if ((_ref1 = paths.root) == null) {
      paths.root = (_ref2 = config.rootPath) != null ? _ref2 : pwd();
    }
    if ((_ref3 = paths["public"]) == null) {
      paths["public"] = (_ref4 = config.buildPath) != null ? _ref4 : joinRoot('public');
    }
    if ((_ref5 = paths.app) == null) {
      paths.app = joinRoot('app');
    }
    if ((_ref6 = paths.generators) == null) {
      paths.generators = joinRoot('generators');
    }
    if ((_ref7 = paths.test) == null) {
      paths.test = joinRoot('test');
    }
    if ((_ref8 = paths.vendor) == null) {
      paths.vendor = joinRoot('vendor');
    }
    if ((_ref9 = paths.assets) == null) {
      paths.assets = join('app', 'assets');
    }
    paths.config = configPath != null ? configPath : joinRoot('config');
    if ((_ref10 = paths.packageConfig) == null) {
      paths.packageConfig = joinRoot('package.json');
    }
    conventions = (_ref11 = config.conventions) != null ? _ref11 : config.conventions = {};
    if ((_ref12 = conventions.assets) == null) {
      conventions.assets = /assets(\/|\\)/;
    }
    if ((_ref13 = conventions.ignored) == null) {
      conventions.ignored = (_ref14 = paths.ignored) != null ? _ref14 : function(path) {
        return startsWith(sysPath.basename(path), '_');
      };
    }
    if ((_ref15 = conventions.tests) == null) {
      conventions.tests = /[-_]test\.\w+$/;
    }
    if ((_ref16 = conventions.vendor) == null) {
      conventions.vendor = /vendor(\/|\\)/;
    }
    if ((_ref17 = config.notifications) == null) {
      config.notifications = true;
    }
    if ((_ref18 = config.optimize) == null) {
      config.optimize = false;
    }
    modules = (_ref19 = config.modules) != null ? _ref19 : config.modules = {};
    if ((_ref20 = modules.wrapper) == null) {
      modules.wrapper = 'commonjs';
    }
    if ((_ref21 = modules.definition) == null) {
      modules.definition = 'commonjs';
    }
    if ((_ref22 = modules.addSourceURLs) == null) {
      modules.addSourceURLs = false;
    }
    if ((_ref23 = config.server) == null) {
      config.server = {};
    }
    if ((_ref24 = (_base = config.server).base) == null) {
      _base.base = '';
    }
    if ((_ref25 = (_base1 = config.server).port) == null) {
      _base1.port = 3333;
    }
    if ((_ref26 = (_base2 = config.server).run) == null) {
      _base2.run = false;
    }
    return config;
  };

  getConfigDeprecations = function(config) {
    var ensureNotArray, messages, warnMoved;

    messages = [];
    warnMoved = function(configItem, from, to) {
      if (configItem) {
        return messages.push("config." + from + " moved to config." + to);
      }
    };
    warnMoved(config.paths.ignored, 'paths.ignored', 'conventions.ignored');
    warnMoved(config.rootPath, 'rootPath', 'paths.root');
    warnMoved(config.buildPath, 'buildPath', 'paths.public');
    ensureNotArray = function(name) {
      if (Array.isArray(config.paths[name])) {
        return messages.push("config.paths." + name + " can't be an array.Use config.conventions." + name);
      }
    };
    ensureNotArray('assets');
    ensureNotArray('test');
    ensureNotArray('vendor');
    return messages;
  };

  normalizeConfig = function(config) {
    var mod, normalized, sourceURLs;

    normalized = {};
    normalized.join = createJoinConfig(config.files);
    mod = config.modules;
    normalized.modules = {};
    sourceURLs = mod.addSourceURLs && !config.optimize;
    normalized.modules.wrapper = normalizeWrapper(mod.wrapper, sourceURLs);
    normalized.modules.definition = normalizeDefinition(mod.definition);
    normalized.conventions = {};
    Object.keys(config.conventions).forEach(function(name) {
      return normalized.conventions[name] = normalizeChecker(config.conventions[name]);
    });
    config._normalized = Object.freeze(normalized);
    return config;
  };

  exports.loadConfig = function(configPath, options) {
    var config, deprecations, error, fullPath, originalConfig;

    if (configPath == null) {
      configPath = 'config';
    }
    if (options == null) {
      options = {};
    }
    fullPath = sysPath.resolve(configPath);
    delete require.cache[fullPath];
    try {
      originalConfig = require(fullPath).config;
    } catch (_error) {
      error = _error;
      throw new Error("couldn\'t load config " + configPath + ". " + error);
    }
    config = extend({}, originalConfig);
    setConfigDefaults(config, configPath);
    deprecations = getConfigDeprecations(config);
    if (deprecations.length > 0) {
      deprecations.forEach(logger.warn);
    }
    recursiveExtend(config, options);
    if (os.platform() === 'win32') {
      replaceSlashes(config);
    }
    normalizeConfig(config);
    deepFreeze(config);
    return config;
  };

  exports.loadPackages = function(rootPath, callback) {
    var deps, err, error, json, nodeModules, plugins, _ref;

    rootPath = sysPath.resolve(rootPath);
    nodeModules = "" + rootPath + "/node_modules";
    try {
      json = require(sysPath.join(rootPath, 'package.json'));
    } catch (_error) {
      err = _error;
      return callback("Current directory is not brunch application root path, as it does not contain package.json (" + err + ")");
    }
    deps = Object.keys(extend((_ref = json.devDependencies) != null ? _ref : {}, json.dependencies));
    try {
      plugins = deps.filter(function(dependency) {
        return dependency !== 'brunch' && dependency.indexOf('brunch') !== -1;
      }).map(function(dependency) {
        return require("" + nodeModules + "/" + dependency);
      });
    } catch (_error) {
      err = _error;
      error = err;
    }
    return callback(error, plugins);
  };

  exports.getPlugins = function(packages, config) {
    return packages.filter(function(plugin) {
      return (plugin.prototype != null) && plugin.prototype.brunchPlugin;
    }).map(function(plugin) {
      return new plugin(config);
    });
  };

}).call(this);
